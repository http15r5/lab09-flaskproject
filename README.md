   # Звіт з контейнеризації проєкту

   ## Огляд проєкту

 [Наш застосунок Flask це сайт з продажем товару та роботи з клієнтами, товаром та відгуками
⦁	 перегляд списку товарів
⦁	 додавання відгуків
⦁	 оформлення замовлень
⦁	 перегляду замовлень у панелі адміністратора
⦁	 клієнтської та серверної логіки на основі Flask + SQLite
⦁	 робота з базою даних SQLite
⦁	 маршрути організовані через Blueprints
⦁	 проєкт було контейнеризовано з використанням Docker та Docker Compose.
збереження даних у локальній SQLite-базі db.sqlite
]

    ## Архітектура контейнерного рішення
⦁	Docker образ

        Базовий образ: python:3.11-slim
        Розмір фінального образу: ~185–220 МБ
        Багатоетапна збірка: так
        Використано окремий етап для встановлення залежностей та мінімальний runtime-образ.

⦁	 Docker Compose

        Кількість сервісів: [web]
        Використовувані volumes: [ sqlite_data → монтує /app/data для збереження бази даних ]

    ## Прийняті рішення та обґрунтування

        ### Вибір базового образу

⦁	  Образ python:3.11-slim було обрано з таких причин:

⦁	  не має проблем зі збіркою Python-бібліотек, які потребують C-компіляції (на відміну від Alpine);

⦁	  менший за звичайний python:3.11;

⦁	  оптимальний баланс між розміром і сумісністю.


        ### Організація збереження даних
⦁	База даних зберігається в окремому volume:

⦁	у контейнері: /app/data/db.sqlite

⦁	локально: docker/volumes/sqlite_data

⦁	база не стирається при перезапуску контейнера;

⦁	можна переносити контейнер без втрати даних;

⦁	відокремлений шар відповідальності — код окремо, дані окремо.


        ### Оптимізації

Було застосовано такі оптимізації:

⦁	використання багатоетапної збірки, щоб фінальний образ був легшим;

⦁	використання volume для збереження бази;

⦁	обмеження прав доступу для папки /app/data;

⦁	додано healthcheck для автоматичної перевірки працездатності сервісу.


      ## Інструкції з розгортання


1.	docker-compose build (для створення контейнера)
2.	docker-compose up (для старту)
3.	docker-compose ps (для перевірки статусу контейнерів)
4.	docker-compose logs (для перевірки логів)
5.	http://localhost:5000 ,   http://127.0.0.1:5000/ (перевірка роботи)
6.	docker-compose down або docker-compose down -v (для зупинки та видалення)
7.	для автоматичного перезапуску restart: unless-stopped
8.	docker-compose run --rm backup (для одноразового бекапу з volume)

## Можливі покращення

...



## Висновки

У ході роботи застосунок було повністю контейнеризовано та ізольовано від системи користувача.
Створений Docker-образ є легким, відтворюваним і запускається на будь-якій машині з Docker.

Контейнеризація дозволила:

забезпечити стабільний робочий оточення;

відокремити дані (SQLite) у volume;

стандартизувати розробку та запуск.

Проєкт успішно працює локально та в Docker-середовищі.
 
